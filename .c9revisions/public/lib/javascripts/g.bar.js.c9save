{"ts":1360256202312,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1360256204589,"patch":[[{"diffs":[[1,"/*!\r\n * g.Raphael 0.51 - Charting library, based on RaphaÃ«l\r\n *\r\n * Copyright (c) 2009-2012 Dmitry Baranovskiy (http://g.raphaeljs.com)\r\n * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.\r\n */\r\n(function () {\r\n    var mmin = Math.min,\r\n        mmax = Math.max;\r\n\r\n    function finger(x, y, width, height, dir, ending, isPath, paper) {\r\n        var path,\r\n            ends = { round: 'round', sharp: 'sharp', soft: 'soft', square: 'square' };\r\n\r\n        // dir 0 for horizontal and 1 for vertical\r\n        if ((dir && !height) || (!dir && !width)) {\r\n            return isPath ? \"\" : paper.path();\r\n        }\r\n\r\n        ending = ends[ending] || \"square\";\r\n        height = Math.round(height);\r\n        width = Math.round(width);\r\n        x = Math.round(x);\r\n        y = Math.round(y);\r\n\r\n        switch (ending) {\r\n            case \"round\":\r\n                if (!dir) {\r\n                    var r = ~~(height / 2);\r\n\r\n                    if (width < r) {\r\n                        r = width;\r\n                        path = [\r\n                            \"M\", x + .5, y + .5 - ~~(height / 2),\r\n                            \"l\", 0, 0,\r\n                            \"a\", r, ~~(height / 2), 0, 0, 1, 0, height,\r\n                            \"l\", 0, 0,\r\n                            \"z\"\r\n                        ];\r\n                    } else {\r\n                        path = [\r\n                            \"M\", x + .5, y + .5 - r,\r\n                            \"l\", width - r, 0,\r\n                            \"a\", r, r, 0, 1, 1, 0, height,\r\n                            \"l\", r - width, 0,\r\n                            \"z\"\r\n                        ];\r\n                    }\r\n                } else {\r\n                    r = ~~(width / 2);\r\n\r\n                    if (height < r) {\r\n                        r = height;\r\n                        path = [\r\n                            \"M\", x - ~~(width / 2), y,\r\n                            \"l\", 0, 0,\r\n                            \"a\", ~~(width / 2), r, 0, 0, 1, width, 0,\r\n                            \"l\", 0, 0,\r\n                            \"z\"\r\n                        ];\r\n                    } else {\r\n                        path = [\r\n                            \"M\", x - r, y,\r\n                            \"l\", 0, r - height,\r\n                            \"a\", r, r, 0, 1, 1, width, 0,\r\n                            \"l\", 0, height - r,\r\n                            \"z\"\r\n                        ];\r\n                    }\r\n                }\r\n                break;\r\n            case \"sharp\":\r\n                if (!dir) {\r\n                    var half = ~~(height / 2);\r\n\r\n                    path = [\r\n                        \"M\", x, y + half,\r\n                        \"l\", 0, -height, mmax(width - half, 0), 0, mmin(half, width), half, -mmin(half, width), half + (half * 2 < height),\r\n                        \"z\"\r\n                    ];\r\n                } else {\r\n                    half = ~~(width / 2);\r\n                    path = [\r\n                        \"M\", x + half, y,\r\n                        \"l\", -width, 0, 0, -mmax(height - half, 0), half, -mmin(half, height), half, mmin(half, height), half,\r\n                        \"z\"\r\n                    ];\r\n                }\r\n                break;\r\n            case \"square\":\r\n                if (!dir) {\r\n                    path = [\r\n                        \"M\", x, y + ~~(height / 2),\r\n                        \"l\", 0, -height, width, 0, 0, height,\r\n                        \"z\"\r\n                    ];\r\n                } else {\r\n                    path = [\r\n                        \"M\", x + ~~(width / 2), y,\r\n                        \"l\", 1 - width, 0, 0, -height, width - 1, 0,\r\n                        \"z\"\r\n                    ];\r\n                }\r\n                break;\r\n            case \"soft\":\r\n                if (!dir) {\r\n                    r = mmin(width, Math.round(height / 5));\r\n                    path = [\r\n                        \"M\", x + .5, y + .5 - ~~(height / 2),\r\n                        \"l\", width - r, 0,\r\n                        \"a\", r, r, 0, 0, 1, r, r,\r\n                        \"l\", 0, height - r * 2,\r\n                        \"a\", r, r, 0, 0, 1, -r, r,\r\n                        \"l\", r - width, 0,\r\n                        \"z\"\r\n                    ];\r\n                } else {\r\n                    r = mmin(Math.round(width / 5), height);\r\n                    path = [\r\n                        \"M\", x - ~~(width / 2), y,\r\n                        \"l\", 0, r - height,\r\n                        \"a\", r, r, 0, 0, 1, r, -r,\r\n                        \"l\", width - 2 * r, 0,\r\n                        \"a\", r, r, 0, 0, 1, r, r,\r\n                        \"l\", 0, height - r,\r\n                        \"z\"\r\n                    ];\r\n                }\r\n        }\r\n\r\n        if (isPath) {\r\n            return path.join(\",\");\r\n        } else {\r\n            return paper.path(path);\r\n        }\r\n    }\r\n\r\n/*\\\r\n * Paper.vbarchart\r\n [ method ]\r\n **\r\n * Creates a vertical bar chart\r\n **\r\n > Parameters\r\n **\r\n - x (number) x coordinate of the chart\r\n - y (number) y coordinate of the chart\r\n - width (number) width of the chart (respected by all elements in the set)\r\n - height (number) height of the chart (respected by all elements in the set)\r\n - values (array) values\r\n - opts (object) options for the chart\r\n o {\r\n o type (string) type of endings of the bar. Default: 'square'. Other options are: 'round', 'sharp', 'soft'.\r\n o gutter (number)(string) default '20%' (WHAT DOES IT DO?)\r\n o vgutter (number)\r\n o colors (array) colors be used repeatedly to plot the bars. If multicolumn bar is used each sequence of bars with use a different color.\r\n o stacked (boolean) whether or not to tread values as in a stacked bar chart\r\n o to\r\n o stretch (boolean)\r\n o }\r\n **\r\n = (object) path element of the popup\r\n > Usage\r\n | r.vbarchart(0, 0, 620, 260, [76, 70, 67, 71, 69], {})\r\n \\*/\r\n \r\n    function VBarchart(paper, x, y, width, height, values, opts) {\r\n        opts = opts || {};\r\n\r\n        var chartinst = this,\r\n            type = opts.type || \"square\",\r\n            gutter = parseFloat(opts.gutter || \"20%\"),\r\n            chart = paper.set(),\r\n            bars = paper.set(),\r\n            covers = paper.set(),\r\n            covers2 = paper.set(),\r\n            total = Math.max.apply(Math, values),\r\n            stacktotal = [],\r\n            multi = 0,\r\n            colors = opts.colors || chartinst.colors,\r\n            len = values.length;\r\n\r\n        if (Raphael.is(values[0], \"array\")) {\r\n            total = [];\r\n            multi = len;\r\n            len = 0;\r\n\r\n            for (var i = values.length; i--;) {\r\n                bars.push(paper.set());\r\n                total.push(Math.max.apply(Math, values[i]));\r\n                len = Math.max(len, values[i].length);\r\n            }\r\n\r\n            if (opts.stacked) {\r\n                for (var i = len; i--;) {\r\n                    var tot = 0;\r\n\r\n                    for (var j = values.length; j--;) {\r\n                        tot +=+ values[j][i] || 0;\r\n                    }\r\n\r\n                    stacktotal.push(tot);\r\n                }\r\n            }\r\n\r\n            for (var i = values.length; i--;) {\r\n                if (values[i].length < len) {\r\n                    for (var j = len; j--;) {\r\n                        values[i].push(0);\r\n                    }\r\n                }\r\n            }\r\n\r\n            total = Math.max.apply(Math, opts.stacked ? stacktotal : total);\r\n        }\r\n        \r\n        total = (opts.to) || total;\r\n\r\n        var barwidth = width / (len * (100 + gutter) + gutter) * 100,\r\n            barhgutter = barwidth * gutter / 100,\r\n            barvgutter = opts.vgutter == null ? 20 : opts.vgutter,\r\n            stack = [],\r\n            X = x + barhgutter,\r\n            Y = (height - 2 * barvgutter) / total;\r\n\r\n        if (!opts.stretch) {\r\n            barhgutter = Math.round(barhgutter);\r\n            barwidth = Math.floor(barwidth);\r\n        }\r\n\r\n        !opts.stacked && (barwidth /= multi || 1);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            stack = [];\r\n\r\n            for (var j = 0; j < (multi || 1); j++) {\r\n                var h = Math.round((multi ? values[j][i] : values[i]) * Y),\r\n                    top = y + height - barvgutter - h,\r\n                    bar = finger(Math.round(X + barwidth / 2), top + h, barwidth, h, true, type, null, paper).attr({ stroke: \"none\", fill: colors[multi ? j : i] });\r\n\r\n                if (multi) {\r\n                    bars[j].push(bar);\r\n                } else {\r\n                    bars.push(bar);\r\n                }\r\n\r\n                bar.y = top;\r\n                bar.x = Math.round(X + barwidth / 2);\r\n                bar.w = barwidth;\r\n                bar.h = h;\r\n                bar.value = multi ? values[j][i] : values[i];\r\n\r\n                if (!opts.stacked) {\r\n                    X += barwidth;\r\n                } else {\r\n                    stack.push(bar);\r\n                }\r\n            }\r\n\r\n            if (opts.stacked) {\r\n                var cvr;\r\n\r\n                covers2.push(cvr = paper.rect(stack[0].x - stack[0].w / 2, y, barwidth, height).attr(chartinst.shim));\r\n                cvr.bars = paper.set();\r\n\r\n                var size = 0;\r\n\r\n                for (var s = stack.length; s--;) {\r\n                    stack[s].toFront();\r\n                }\r\n\r\n                for (var s = 0, ss = stack.length; s < ss; s++) {\r\n                    var bar = stack[s],\r\n                        cover,\r\n                        h = (size + bar.value) * Y,\r\n                        path = finger(bar.x, y + height - barvgutter - !!size * .5, barwidth, h, true, type, 1, paper);\r\n\r\n                    cvr.bars.push(bar);\r\n                    size && bar.attr({path: path});\r\n                    bar.h = h;\r\n                    bar.y = y + height - barvgutter - !!size * .5 - h;\r\n                    covers.push(cover = paper.rect(bar.x - bar.w / 2, bar.y, barwidth, bar.value * Y).attr(chartinst.shim));\r\n                    cover.bar = bar;\r\n                    cover.value = bar.value;\r\n                    size += bar.value;\r\n                }\r\n\r\n                X += barwidth;\r\n            }\r\n\r\n            X += barhgutter;\r\n        }\r\n\r\n        covers2.toFront();\r\n        X = x + barhgutter;\r\n\r\n        if (!opts.stacked) {\r\n            for (var i = 0; i < len; i++) {\r\n                for (var j = 0; j < (multi || 1); j++) {\r\n                    var cover;\r\n\r\n                    covers.push(cover = paper.rect(Math.round(X), y + barvgutter, barwidth, height - barvgutter).attr(chartinst.shim));\r\n                    cover.bar = multi ? bars[j][i] : bars[i];\r\n                    cover.value = cover.bar.value;\r\n                    X += barwidth;\r\n                }\r\n\r\n                X += barhgutter;\r\n            }\r\n        }\r\n\r\n        chart.label = function (labels, isBottom) {\r\n            labels = labels || [];\r\n            this.labels = paper.set();\r\n\r\n            var L, l = -Infinity;\r\n\r\n            if (opts.stacked) {\r\n                for (var i = 0; i < len; i++) {\r\n                    var tot = 0;\r\n\r\n                    for (var j = 0; j < (multi || 1); j++) {\r\n                        tot += multi ? values[j][i] : values[i];\r\n\r\n                        if (j == multi - 1) {\r\n                            var label = paper.labelise(labels[i], tot, total);\r\n\r\n                            L = paper.text(bars[i * (multi || 1) + j].x, y + height - barvgutter / 2, label).attr(txtattr).insertBefore(covers[i * (multi || 1) + j]);\r\n\r\n                            var bb = L.getBBox();\r\n\r\n                            if (bb.x - 7 < l) {\r\n                                L.remove();\r\n                            } else {\r\n                                this.labels.push(L);\r\n                                l = bb.x + bb.width;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                for (var i = 0; i < len; i++) {\r\n                    for (var j = 0; j < (multi || 1); j++) {\r\n                        var label = paper.labelise(multi ? labels[j] && labels[j][i] : labels[i], multi ? values[j][i] : values[i], total);\r\n\r\n                        L = paper.text(bars[i * (multi || 1) + j].x, isBottom ? y + height - barvgutter / 2 : bars[i * (multi || 1) + j].y - 10, label).attr(txtattr).insertBefore(covers[i * (multi || 1) + j]);\r\n\r\n                        var bb = L.getBBox();\r\n\r\n                        if (bb.x - 7 < l) {\r\n                            L.remove();\r\n                        } else {\r\n                            this.labels.push(L);\r\n                            l = bb.x + bb.width;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n\r\n        chart.hover = function (fin, fout) {\r\n            covers2.hide();\r\n            covers.show();\r\n            covers.mouseover(fin).mouseout(fout);\r\n            return this;\r\n        };\r\n\r\n        chart.hoverColumn = function (fin, fout) {\r\n            covers.hide();\r\n            covers2.show();\r\n            fout = fout || function () {};\r\n            covers2.mouseover(fin).mouseout(fout);\r\n            return this;\r\n        };\r\n\r\n        chart.click = function (f) {\r\n            covers2.hide();\r\n            covers.show();\r\n            covers.click(f);\r\n            return this;\r\n        };\r\n\r\n        chart.each = function (f) {\r\n            if (!Raphael.is(f, \"function\")) {\r\n                return this;\r\n            }\r\n            for (var i = covers.length; i--;) {\r\n                f.call(covers[i]);\r\n            }\r\n            return this;\r\n        };\r\n\r\n        chart.eachColumn = function (f) {\r\n            if (!Raphael.is(f, \"function\")) {\r\n                return this;\r\n            }\r\n            for (var i = covers2.length; i--;) {\r\n                f.call(covers2[i]);\r\n            }\r\n            return this;\r\n        };\r\n\r\n        chart.clickColumn = function (f) {\r\n            covers.hide();\r\n            covers2.show();\r\n            covers2.click(f);\r\n            return this;\r\n        };\r\n\r\n        chart.push(bars, covers, covers2);\r\n        chart.bars = bars;\r\n        chart.covers = covers;\r\n        return chart;\r\n    };\r\n    \r\n    //inheritance\r\n    var F = function() {};\r\n    F.prototype = Raphael.g;\r\n    HBarchart.prototype = VBarchart.prototype = new F; //prototype reused by hbarchart\r\n    \r\n    Raphael.fn.barchart = function(x, y, width, height, values, opts) {\r\n        return new VBarchart(this, x, y, width, height, values, opts);\r\n    };\r\n    \r\n/*\\\r\n * Paper.barchart\r\n [ method ]\r\n **\r\n * Creates a horizontal bar chart\r\n **\r\n > Parameters\r\n **\r\n - x (number) x coordinate of the chart\r\n - y (number) y coordinate of the chart\r\n - width (number) width of the chart (respected by all elements in the set)\r\n - height (number) height of the chart (respected by all elements in the set)\r\n - values (array) values\r\n - opts (object) options for the chart\r\n o {\r\n o type (string) type of endings of the bar. Default: 'square'. Other options are: 'round', 'sharp', 'soft'.\r\n o gutter (number)(string) default '20%' (WHAT DOES IT DO?)\r\n o vgutter (number)\r\n o colors (array) colors be used repeatedly to plot the bars. If multicolumn bar is used each sequence of bars with use a different color.\r\n o stacked (boolean) whether or not to tread values as in a stacked bar chart\r\n o to\r\n o stretch (boolean)\r\n o }\r\n **\r\n = (object) path element of the popup\r\n > Usage\r\n | r.barchart(0, 0, 620, 260, [76, 70, 67, 71, 69], {})\r\n \\*/\r\n \r\n    function HBarchart(paper, x, y, width, height, values, opts) {\r\n        opts = opts || {};\r\n\r\n        var chartinst = this,\r\n            type = opts.type || \"square\",\r\n            gutter = parseFloat(opts.gutter || \"20%\"),\r\n            chart = paper.set(),\r\n            bars = paper.set(),\r\n            covers = paper.set(),\r\n            covers2 = paper.set(),\r\n            total = Math.max.apply(Math, values),\r\n            stacktotal = [],\r\n            multi = 0,\r\n            colors = opts.colors || chartinst.colors,\r\n            len = values.length;\r\n\r\n        if (Raphael.is(values[0], \"array\")) {\r\n            total = [];\r\n            multi = len;\r\n            len = 0;\r\n\r\n            for (var i = values.length; i--;) {\r\n                bars.push(paper.set());\r\n                total.push(Math.max.apply(Math, values[i]));\r\n                len = Math.max(len, values[i].length);\r\n            }\r\n\r\n            if (opts.stacked) {\r\n                for (var i = len; i--;) {\r\n                    var tot = 0;\r\n                    for (var j = values.length; j--;) {\r\n                        tot +=+ values[j][i] || 0;\r\n                    }\r\n                    stacktotal.push(tot);\r\n                }\r\n            }\r\n\r\n            for (var i = values.length; i--;) {\r\n                if (values[i].length < len) {\r\n                    for (var j = len; j--;) {\r\n                        values[i].push(0);\r\n                    }\r\n                }\r\n            }\r\n\r\n            total = Math.max.apply(Math, opts.stacked ? stacktotal : total);\r\n        }\r\n        \r\n        total = (opts.to) || total;\r\n\r\n        var barheight = Math.floor(height / (len * (100 + gutter) + gutter) * 100),\r\n            bargutter = Math.floor(barheight * gutter / 100),\r\n            stack = [],\r\n            Y = y + bargutter,\r\n            X = (width - 1) / total;\r\n\r\n        !opts.stacked && (barheight /= multi || 1);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n            stack = [];\r\n\r\n            for (var j = 0; j < (multi || 1); j++) {\r\n                var val = multi ? values[j][i] : values[i],\r\n                    bar = finger(x, Y + barheight / 2, Math.round(val * X), barheight - 1, false, type, null, paper).attr({stroke: \"none\", fill: colors[multi ? j : i]});\r\n\r\n                if (multi) {\r\n                    bars[j].push(bar);\r\n                } else {\r\n                    bars.push(bar);\r\n                }\r\n\r\n                bar.x = x + Math.round(val * X);\r\n                bar.y = Y + barheight / 2;\r\n                bar.w = Math.round(val * X);\r\n                bar.h = barheight;\r\n                bar.value = +val;\r\n\r\n                if (!opts.stacked) {\r\n                    Y += barheight;\r\n                } else {\r\n                    stack.push(bar);\r\n                }\r\n            }\r\n\r\n            if (opts.stacked) {\r\n                var cvr = paper.rect(x, stack[0].y - stack[0].h / 2, width, barheight).attr(chartinst.shim);\r\n\r\n                covers2.push(cvr);\r\n                cvr.bars = paper.set();\r\n\r\n                var size = 0;\r\n\r\n                for (var s = stack.length; s--;) {\r\n                    stack[s].toFront();\r\n                }\r\n\r\n                for (var s = 0, ss = stack.length; s < ss; s++) {\r\n                    var bar = stack[s],\r\n                        cover,\r\n                        val = Math.round((size + bar.value) * X),\r\n                        path = finger(x, bar.y, val, barheight - 1, false, type, 1, paper);\r\n\r\n                    cvr.bars.push(bar);\r\n                    size && bar.attr({ path: path });\r\n                    bar.w = val;\r\n                    bar.x = x + val;\r\n                    covers.push(cover = paper.rect(x + size * X, bar.y - bar.h / 2, bar.value * X, barheight).attr(chartinst.shim));\r\n                    cover.bar = bar;\r\n                    size += bar.value;\r\n                }\r\n\r\n                Y += barheight;\r\n            }\r\n\r\n            Y += bargutter;\r\n        }\r\n\r\n        covers2.toFront();\r\n        Y = y + bargutter;\r\n\r\n        if (!opts.stacked) {\r\n            for (var i = 0; i < len; i++) {\r\n                for (var j = 0; j < (multi || 1); j++) {\r\n                    var cover = paper.rect(x, Y, width, barheight).attr(chartinst.shim);\r\n\r\n                    covers.push(cover);\r\n                    cover.bar = multi ? bars[j][i] : bars[i];\r\n                    cover.value = cover.bar.value;\r\n                    Y += barheight;\r\n                }\r\n\r\n                Y += bargutter;\r\n            }\r\n        }\r\n\r\n        chart.label = function (labels, isRight) {\r\n            labels = labels || [];\r\n            this.labels = paper.set();\r\n\r\n            for (var i = 0; i < len; i++) {\r\n                for (var j = 0; j < multi; j++) {\r\n                    var  label = paper.labelise(multi ? labels[j] && labels[j][i] : labels[i], multi ? values[j][i] : values[i], total),\r\n                        X = isRight ? bars[i * (multi || 1) + j].x - barheight / 2 + 3 : x + 5,\r\n                        A = isRight ? \"end\" : \"start\",\r\n                        L;\r\n\r\n                    this.labels.push(L = paper.text(X, bars[i * (multi || 1) + j].y, label).attr(txtattr).attr({ \"text-anchor\": A }).insertBefore(covers[0]));\r\n\r\n                    if (L.getBBox().x < x + 5) {\r\n                        L.attr({x: x + 5, \"text-anchor\": \"start\"});\r\n                    } else {\r\n                        bars[i * (multi || 1) + j].label = L;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return this;\r\n        };\r\n\r\n        chart.hover = function (fin, fout) {\r\n            covers2.hide();\r\n            covers.show();\r\n            fout = fout || function () {};\r\n            covers.mouseover(fin).mouseout(fout);\r\n            return this;\r\n        };\r\n\r\n        chart.hoverColumn = function (fin, fout) {\r\n            covers.hide();\r\n            covers2.show();\r\n            fout = fout || function () {};\r\n            covers2.mouseover(fin).mouseout(fout);\r\n            return this;\r\n        };\r\n\r\n        chart.each = function (f) {\r\n            if (!Raphael.is(f, \"function\")) {\r\n                return this;\r\n            }\r\n            for (var i = covers.length; i--;) {\r\n                f.call(covers[i]);\r\n            }\r\n            return this;\r\n        };\r\n\r\n        chart.eachColumn = function (f) {\r\n            if (!Raphael.is(f, \"function\")) {\r\n                return this;\r\n            }\r\n            for (var i = covers2.length; i--;) {\r\n                f.call(covers2[i]);\r\n            }\r\n            return this;\r\n        };\r\n\r\n        chart.click = function (f) {\r\n            covers2.hide();\r\n            covers.show();\r\n            covers.click(f);\r\n            return this;\r\n        };\r\n\r\n        chart.clickColumn = function (f) {\r\n            covers.hide();\r\n            covers2.show();\r\n            covers2.click(f);\r\n            return this;\r\n        };\r\n\r\n        chart.push(bars, covers, covers2);\r\n        chart.bars = bars;\r\n        chart.covers = covers;\r\n        return chart;\r\n    };\r\n    \r\n    Raphael.fn.hbarchart = function(x, y, width, height, values, opts) {\r\n        return new HBarchart(this, x, y, width, height, values, opts);\r\n    };\r\n    \r\n})();"]],"start1":0,"start2":0,"length1":0,"length2":22831}]],"length":22831,"saved":false}
