{"ts":1360017697379,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1360017699133,"patch":[[{"diffs":[[1,"(function(_, Backbone) {\r\n\r\n// Require Underscore and Backbone if there's a `require` function.\r\n// This makes `backbone.queryparam` work on the server or when using\r\n// `browserify`.\r\nif (typeof require !== 'undefined') {\r\n  _ = _ || require('underscore');\r\n  Backbone = Backbone || require('backbone');\r\n}\r\n\r\nvar queryStringParam = /^\\?(.*)/,\r\n    optionalParam = /\\((.*?)\\)/g,\r\n    namedParam    = /(\\(\\?)?:\\w+/g,\r\n    splatParam    = /\\*\\w+/g,\r\n    escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g,\r\n    queryStrip = /(\\?.*)$/,\r\n    fragmentStrip = /^([^\\?]*)/,\r\n    namesPattern = /[\\:\\*]([^\\:\\?\\/]+)/g;\r\nBackbone.Router.arrayValueSplit = '|';\r\n\r\nvar _getFragment = Backbone.History.prototype.getFragment;\r\n\r\n_.extend(Backbone.History.prototype, {\r\n  getFragment : function(fragment, forcePushState, excludeQueryString) {\r\n    fragment = _getFragment.apply(this, arguments);\r\n    if (excludeQueryString) {\r\n      fragment = fragment.replace(queryStrip, '');\r\n    }\r\n    return fragment;\r\n  },\r\n\r\n  // this will not perform custom query param serialization specific to the router\r\n  // but will return a map of key/value pairs (the value is a string or array)\r\n  getQueryParameters : function(fragment, forcePushState) {\r\n    fragment = _getFragment.apply(this, arguments);\r\n    // if no query string exists, this will still be the original fragment\r\n    var queryString = fragment.replace(fragmentStrip, '');\r\n    var match = queryString.match(queryStringParam);\r\n    if (match) {\r\n      queryString = match[1];\r\n      var rtn = {};\r\n      iterateQueryString(queryString, function(name, value) {\r\n        if (!rtn[name]) {\r\n          rtn[name] = value;\r\n        } else if (_.isString(rtn[name])) {\r\n          rtn[name] = [rtn[name], value];\r\n        } else {\r\n          rtn[name].push(value);\r\n        }\r\n      });\r\n      return rtn;\r\n    } else {\r\n      // no values\r\n      return {};\r\n    }\r\n  }\r\n});\r\n\r\n_.extend(Backbone.Router.prototype, {\r\n  initialize: function(options) {\r\n    this.encodedSplatParts = options && options.encodedSplatParts;\r\n  },\r\n\r\n  getFragment : function(fragment, forcePushState, excludeQueryString) {\r\n    fragment = _getFragment.apply(this, arguments);\r\n    if (excludeQueryString) {\r\n      fragment = fragment.replace(queryStrip, '');\r\n    }\r\n    return fragment;\r\n  },\r\n\r\n  _routeToRegExp: function(route) {\r\n    var splatMatch = (splatParam.exec(route) || {index: -1}),\r\n        namedMatch = (namedParam.exec(route) || {index: -1}),\r\n        paramNames = route.match(namesPattern) || [];\r\n\r\n    route = route.replace(escapeRegExp, '\\\\$&')\r\n                 .replace(optionalParam, '(?:$1)?')\r\n                 .replace(namedParam, function(match, optional){\r\n                   return optional ? match : '([^\\\\/\\\\?]+)';\r\n                 })\r\n                 .replace(splatParam, '([^\\?]*?)');\r\n    route += '([\\?]{1}.*)?';\r\n    var rtn = new RegExp('^' + route + '$');\r\n\r\n  // use the rtn value to hold some parameter data\r\n  if (splatMatch.index >= 0) {\r\n    // there is a splat\r\n    if (namedMatch >= 0) {\r\n      // negative value will indicate there is a splat match before any named matches\r\n      rtn.splatMatch = splatMatch.index - namedMatch.index;\r\n    } else {\r\n      rtn.splatMatch = -1;\r\n    }\r\n  }\r\n  rtn.paramNames = _.map(paramNames, function(name) { return name.substring(1); });\r\n  rtn.namedParameters = this.namedParameters;\r\n\r\n  return rtn;\r\n  },\r\n\r\n  /**\r\n   * Given a route, and a URL fragment that it matches, return the array of\r\n   * extracted parameters.\r\n   */\r\n  _extractParameters : function(route, fragment) {\r\n    var params = route.exec(fragment).slice(1),\r\n        namedParams = {};\r\n\r\n    // do we have an additional query string?\r\n    var match = params.length && params[params.length-1] && params[params.length-1].match(queryStringParam);\r\n    if (match) {\r\n      var queryString = match[1];\r\n      var data = {};\r\n      if (queryString) {\r\n        var self = this;\r\n        iterateQueryString(queryString, function(name, value) {\r\n          self._setParamValue(name, value, data);\r\n        });\r\n      }\r\n      params[params.length-1] = data;\r\n      _.extend(namedParams, data);\r\n    }\r\n\r\n    // decode params\r\n    var length = params.length;\r\n    if (route.splatMatch && this.encodedSplatParts) {\r\n      if (route.splatMatch < 0) {\r\n        // splat param is first\r\n        return params;\r\n      } else {\r\n        length = length - 1;\r\n      }\r\n    }\r\n\r\n    for (var i=0; i<length; i++) {\r\n      if (_.isString(params[i])) {\r\n        params[i] = Backbone.Router.decodeParams ? decodeURIComponent(params[i]) : params[i];\r\n        if (route.paramNames.length >= i-1) {\r\n          namedParams[route.paramNames[i]] = params[i];\r\n        }\r\n      }\r\n    }\r\n\r\n    return (Backbone.Router.namedParameters || route.namedParameters) ? [namedParams] : params;\r\n  },\r\n\r\n  /**\r\n   * Set the parameter value on the data hash\r\n   */\r\n  _setParamValue : function(key, value, data) {\r\n    // use '.' to define hash separators\r\n    var parts = key.split('.');\r\n    var _data = data;\r\n    for (var i=0; i<parts.length; i++) {\r\n      var part = parts[i];\r\n      if (i === parts.length-1) {\r\n        // set the value\r\n        _data[part] = this._decodeParamValue(value, _data[part]);\r\n      } else {\r\n        _data = _data[part] = _data[part] || {};\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Decode an individual parameter value (or list of values)\r\n   * @param value the complete value\r\n   * @param currentValue the currently known value (or list of values)\r\n   */\r\n  _decodeParamValue : function(value, currentValue) {\r\n    // '|' will indicate an array.  Array with 1 value is a=|b - multiple values can be a=b|c\r\n    var splitChar = Backbone.Router.arrayValueSplit;\r\n    if (value.indexOf(splitChar) >= 0) {\r\n      var values = value.split(splitChar);\r\n      // clean it up\r\n      for (var i=values.length-1; i>=0; i--) {\r\n        if (!values[i]) {\r\n          values.splice(i, 1);\r\n        } else {\r\n          values[i] = decodeURIComponent(values[i]);\r\n        }\r\n      }\r\n      return values;\r\n    }\r\n    if (!currentValue) {\r\n      return decodeURIComponent(value);\r\n    } else if (_.isArray(currentValue)) {\r\n      currentValue.push(decodeURIComponent(value));\r\n      return currentValue;\r\n    } else {\r\n      return [currentValue, decodeURIComponent(value)];\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Return the route fragment with queryParameters serialized to query parameter string\r\n   */\r\n  toFragment: function(route, queryParameters) {\r\n    if (queryParameters) {\r\n      if (!_.isString(queryParameters)) {\r\n        queryParameters = this._toQueryString(queryParameters);\r\n      }\r\n      if(queryParameters) {\r\n        route += '?' + queryParameters;\r\n      }\r\n    }\r\n    return route;\r\n  },\r\n\r\n  /**\r\n   * Serialize the val hash to query parameters and return it.  Use the namePrefix to prefix all param names (for recursion)\r\n   */\r\n  _toQueryString: function(val, namePrefix) {\r\n    var splitChar = Backbone.Router.arrayValueSplit;\r\n    function encodeSplit(val) { return val.replace(splitChar, encodeURIComponent(splitChar)); }\r\n\r\n    if (!val) return '';\r\n    namePrefix = namePrefix || '';\r\n    var rtn = '';\r\n    for (var name in val) {\r\n      var _val = val[name];\r\n      if (_.isString(_val) || _.isNumber(_val) || _.isBoolean(_val) || _.isDate(_val)) {\r\n        // primitive type\r\n        _val = this._toQueryParam(_val);\r\n        if (_.isBoolean(_val) || _.isNumber(_val) || _val) {\r\n          rtn += (rtn ? '&' : '') + this._toQueryParamName(name, namePrefix) + '=' + encodeSplit(encodeURIComponent(_val));\r\n        }\r\n      } else if (_.isArray(_val)) {\r\n        // arrays use Backbone.Router.arrayValueSplit separator\r\n        var str = '';\r\n        for (var i in _val) {\r\n          var param = this._toQueryParam(_val[i]);\r\n          if (_.isBoolean(param) || param) {\r\n            str += splitChar + encodeSplit(param);\r\n          }\r\n        }\r\n        if (str) {\r\n          rtn += (rtn ? '&' : '') + this._toQueryParamName(name, namePrefix) + '=' + str;\r\n        }\r\n      } else {\r\n        // dig into hash\r\n        var result = this._toQueryString(_val, this._toQueryParamName(name, namePrefix, true));\r\n        if (result) {\r\n          rtn += (rtn ? '&' : '') + result;\r\n        }\r\n      }\r\n    }\r\n    return rtn;\r\n  },\r\n\r\n  /**\r\n   * return the actual parameter name\r\n   * @param name the parameter name\r\n   * @param namePrefix the prefix to the name\r\n   * @param createPrefix true if we're creating a name prefix, false if we're creating the name\r\n   */\r\n  _toQueryParamName: function(name, prefix, isPrefix) {\r\n    return (prefix + name + (isPrefix ? '.' : ''));\r\n  },\r\n\r\n  /**\r\n   * Return the string representation of the param used for the query string\r\n   */\r\n  _toQueryParam: function (param) {\r\n    if (_.isNull(param) || _.isUndefined(param)) {\r\n      return null;\r\n    }\r\n    return param;\r\n  }\r\n});\r\n\r\nfunction iterateQueryString(queryString, callback) {\r\n  var keyValues = queryString.split('&');\r\n  _.each(keyValues, function(keyValue) {\r\n    var i = keyValue.indexOf('=');\r\n    var arr = [keyValue.slice(0,i), keyValue.slice(i+1)];\r\n    if (arr.length > 1) {\r\n      callback(arr[0], arr[1]);\r\n    }\r\n  });\r\n}\r\n\r\n})(typeof _ === 'undefined' ? null : _, typeof Backbone === 'undefined' ? null : Backbone);"]],"start1":0,"start2":0,"length1":0,"length2":9280}]],"length":9280,"saved":false}
